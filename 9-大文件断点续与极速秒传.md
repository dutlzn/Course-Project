---

---

#  大文件断点续传与极速秒传

# 分片传输的试探

文件越大，上传失败率越大

当文件上传到一般，网络断了，下次再上传，只上传剩下的一般，这就是

断点续传



极速秒传，开始上传之前，先检查一下文件有没有上传过，

如果已经上传过了，直接弹出提示，极速秒传成功



一个文件有10m，每个分片定义为1m， 那这个文件就会被分为10片



前端，拷贝file.vue 组件， 定义为big-file.vue



big-file.vue 

```vue
		if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

// 文件分片
				let shardSize = 20*1024*1024;// 20mb为一个分片
				let shardIndex = 1;//分片索引
				let start = shardIndex * shardSize;// 当前分片起始位置
				let end = Math.min(file.size, start + shardSize);//当前分片结束位置
				let fileShard = file.slice(start, end);
				
				console.log(fileShard);
				
				formData.append('file', fileShard);
				formData.append('use', _this.use);
				
```



## 分片的合并

后端

```java
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(
            @RequestParam MultipartFile file,
            String use
            ) throws IOException {

        LOG.info(file.getOriginalFilename());
        LOG.info(String.valueOf(file.getSize()));

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        String fileName=  file.getOriginalFilename();
        String suffix = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
        String key = UuidUtil.getShortUuid();

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        file.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        FileDto fileDto = new FileDto();
        fileDto.setPath(path);
        fileDto.setName(fileName);
        fileDto.setSize(Math.toIntExact(file.getSize()));
        fileDto.setSuffix(suffix);
        fileDto.setUse(use);


        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test1234.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/RGg2NUt6.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/WWn2wJyZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}

```

先测试一下

http://localhost:9000/file/admin/merge

这里要注意一个东西就是一个文件需要完整分割成几份，合并起来才可以播放





# 分片上传功能开发

## 数据库

```sql
alter table `file` add column (`shard_index` int comment '已上传分片');
alter table `file` add column (`shard_size` int comment '分片大小|B');
alter table `file` add column (`shard_total` int comment '分片总数');
alter table `file` add column (`key` varchar(32) comment '文件标识');
alter table `file` add unique key key_unique (`key`);

```

不管传过来第几个分片，key是一样的



mybatis file 生成持久层代码





## 分片数据传输

经验： 对于一些不涉及安全性的数据，可以交由前端来计算，这样可以减轻服务端的压力



fileDto

```
package com.lzn.dto;

import java.util.Date;
import com.fasterxml.jackson.annotation.JsonFormat;

public class FileDto {

    /**
     * id
     */
    private String id;

    /**
     * 相对路径
     */
    private String path;

    /**
     * 文件名
     */
    private String name;

    /**
     * 后缀
     */
    private String suffix;

    /**
     * 大小|字节B
     */
    private Integer size;

    /**
     * 用途|枚举[FileUseEnum]：COURSE("C", "讲师"), TEACHER("T", "课程")
     */
    private String use;

    /**
     * 创建时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createdAt;

    /**
     * 修改时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updatedAt;


    private Integer shardIndex;
    private Integer shardSize;
    private Integer shardTotal;
    private String key;

    @Override
    public String toString() {
        return "FileDto{" +
                "id='" + id + '\'' +
                ", path='" + path + '\'' +
                ", name='" + name + '\'' +
                ", suffix='" + suffix + '\'' +
                ", size=" + size +
                ", use='" + use + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                ", shardIndex=" + shardIndex +
                ", shardSize=" + shardSize +
                ", shardTotal=" + shardTotal +
                ", key='" + key + '\'' +
                '}';
    }

    public Integer getShardIndex() {
        return shardIndex;
    }

    public void setShardIndex(Integer shardIndex) {
        this.shardIndex = shardIndex;
    }

    public Integer getShardSize() {
        return shardSize;
    }

    public void setShardSize(Integer shardSize) {
        this.shardSize = shardSize;
    }

    public Integer getShardTotal() {
        return shardTotal;
    }

    public void setShardTotal(Integer shardTotal) {
        this.shardTotal = shardTotal;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public String getUse() {
        return use;
    }

    public void setUse(String use) {
        this.use = use;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }


}
```



big-file.vue

```
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
					{{ text }}
			</v-btn>
		</v-col>
		
		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
	<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];
				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}
				
				// 文件分片
				let shardSize = 20*1024*1024;// 20mb为一个分片
				let shardIndex = 1;//分片索引
				let start = shardIndex * shardSize;// 当前分片起始位置
				let end = Math.min(file.size, start + shardSize);//当前分片结束位置
				let fileShard = file.slice(start, end);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数
				
				
				
				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致
				formData.append('shard', fileShard);
				formData.append('shardIndex', shardIndex);
				formData.append('shardSize', shardSize);
			  formData.append('shardTotal', shardTotal);
				formData.append('use', _this.use);
				formData.append('name', file.name);
				formData.append('suffix', suffix);
				formData.append('size', size);
				
				Loading.show();
				_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', formData).then((response) => {
					Loading.hide();
					let resp = response.data;
					_this.afterUpload(resp);
					
					// 清空，下次在选择同一个东西时候，也会触发
					$("#" + _this.intputId + "-input").val("");
					

				})
			},

			selectFile() {
				let _this = this;
        $("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
   input {
		 /* 设计透明度 */
     opacity: 0;

    }
</style>

```



key是唯一建，不能为空，所以先存短uuid，让程序走通

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(
            @RequestParam MultipartFile shard,
            String use,
            String name,
            String suffix,
            Integer size,
            Integer shardIndex,
            Integer shardSize,
            Integer shardTotal
            ) throws IOException {

        LOG.info("上传文件开始");

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        String key = UuidUtil.getShortUuid();

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        FileDto fileDto = new FileDto();
        fileDto.setPath(path);
        fileDto.setName(name);
        fileDto.setSize(size);
        fileDto.setSuffix(suffix);
        fileDto.setUse(use);
        fileDto.setShardIndex(shardIndex);
        fileDto.setShardSize(shardSize);
        fileDto.setShardTotal(shardTotal);
        fileDto.setKey(key);
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/0mUkwqKQ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/FInyTgeZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}
```





## 文件标识的设计

数据库设计：

上传第一个分片，插入一条记录，上传之后的分片，都是更新记录，只需要更新shard_index字段，当然也包括updated-at



不管上传第几个分片，传输的key值是一样的，key跟文件无关，跟分片无关

md5信息摘要算法：常用于密码加密传输与存储，会生成128位二进制数，没4个二进制可以转成1个16进制数，结果是32个16进制数字

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(
            @RequestParam MultipartFile shard,
            String use,
            String name,
            String suffix,
            Integer size,
            Integer shardIndex,
            Integer shardSize,
            Integer shardTotal,
            String key
            ) throws IOException {

        LOG.info("上传文件开始");

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        FileDto fileDto = new FileDto();
        fileDto.setPath(path);
        fileDto.setName(name);
        fileDto.setSize(size);
        fileDto.setSuffix(suffix);
        fileDto.setUse(use);
        fileDto.setShardIndex(shardIndex);
        fileDto.setShardSize(shardSize);
        fileDto.setShardTotal(shardTotal);
        fileDto.setKey(key);
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/0mUkwqKQ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/FInyTgeZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}

```





引入md5.js public static js

```js
var KEY = "!@#QWERT";
/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}
function b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}
function str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}
function hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }
function b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }
function str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
function core_hmac_md5(key, data)
{
  var bkey = str2binl(key);
  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
  return core_md5(opad.concat(hash), 512 + 128);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
  return bin;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
  return str;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of little-endian words to a base-64 string
 */
function binl2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}

```



index.html 引入md5.js



62 26个大写字母+26个小写字母+10个阿拉伯数字 62个字符，可以表达

62进制数





tools.js

```js
Tool = {
	/**
	 * 空校验 null或""都返回true
	 */
	isEmpty: function(obj) {
		if ((typeof obj == 'string')) {
			// https://blog.csdn.net/dreamjay1997/article/details/86599404
			return !obj || obj.replace(/\s+/g, "") == ""
		} else {
			return (!obj || JSON.stringify(obj) === "{}" || obj.length === 0);
		}
	},

	/**
	 * 非空校验
	 */
	isNotEmpty: function(obj) {
		return !this.isEmpty(obj);
	},

	/**
	 * 长度校验
	 */
	isLength: function(str, min, max) {
		return $.trim(str).length >= min && $.trim(str).length <= max;
	},

	/**
	 * 时间格式化，date为空时取当前时间
	 */
	dateFormat: function(format, date) {
		let result;
		if (!date) {
			date = new Date();
		}
		const option = {
			"y+": date.getFullYear().toString(), // 年
			"M+": (date.getMonth() + 1).toString(), // 月
			"d+": date.getDate().toString(), // 日
			"h+": date.getHours().toString(), // 时
			"m+": date.getMinutes().toString(), // 分
			"s+": date.getSeconds().toString() // 秒
		};
		for (let i in option) {
			result = new RegExp("(" + i + ")").exec(format);
			if (result) {
				format = format.replace(result[1], (result[1].length == 1) ? (option[i]) : (option[i].padStart(result[1].length,
					"0")))
			}
		}
		return format;
	},


	/**
	 * 10进制转62进制
	 * @param number
	 * @returns {string}
	 * @private
	 */
	_10to62: function(number) {
		let chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ';
		let radix = chars.length;
		let arr = [];
		do {
			let mod = number % radix;
			number = (number - mod) / radix;
			arr.unshift(chars[mod]);
		} while (number);
		return arr.join('');
	},

}

```



big-file.vue

```vue
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
				{{ text }}
			</v-btn>
		</v-col>

		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
		<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];


				// console.log(JSON.stringify(file));
				/*
				  name: "test.mp4"
				  lastModified: 1901173357457
				  lastModifiedDate: Tue May 27 2099 14:49:17 GMT+0800 (中国标准时间) {}
				  webkitRelativePath: ""
				  size: 37415970
				  type: "video/mp4"
				*/
			 
			 // 文件标识
        let key = hex_md5(file);
        let key10 = parseInt(key, 16);
        let key62 = Tool._10to62(key10);
				console.log(key, key10, key62);


				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

				// 文件分片
				let shardSize = 20 * 1024 * 1024; // 20mb为一个分片
				let shardIndex = 1; //分片索引
				let start = shardIndex * shardSize; // 当前分片起始位置
				let end = Math.min(file.size, start + shardSize); //当前分片结束位置
				let fileShard = file.slice(start, end);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数



				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致
				formData.append('shard', fileShard);
				formData.append('shardIndex', shardIndex);
				formData.append('shardSize', shardSize);
				formData.append('shardTotal', shardTotal);
				formData.append('use', _this.use);
				formData.append('name', file.name);
				formData.append('suffix', suffix);
				formData.append('size', size);
				formData.append('key', key62);

				Loading.show();
				_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', formData).then((response) => {
					Loading.hide();
					let resp = response.data;
					_this.afterUpload(resp);

					// 清空，下次在选择同一个东西时候，也会触发
					$("#" + _this.intputId + "-input").val("");


				})
			},

			selectFile() {
				let _this = this;
				$("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
	input {
		/* 设计透明度 */
		opacity: 0;

	}
</style>

```





从数据库里查出来的对象，可以用Db结尾

fileService.java

```java
package com.lzn.service;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.lzn.domain.File;
import com.lzn.domain.FileExample;
import com.lzn.domain.Test;
import com.lzn.domain.TestExample;
import com.lzn.dto.FileDto;
import com.lzn.dto.PageDto;
import com.lzn.mapper.FileMapper;
import com.lzn.mapper.TestMapper;
import com.lzn.util.CopyUtil;
import com.lzn.util.UuidUtil;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

import java.util.Date;

@Service
public class FileService {

    @Autowired
    private FileMapper fileMapper;


    public void list(PageDto pageDto) {

        PageHelper.startPage(pageDto.getPage(), pageDto.getSize());
        FileExample fileExample = new FileExample();


        List<File> fileList = fileMapper.selectByExample(fileExample);

        PageInfo<File> pageInfo = new PageInfo<>(fileList);
        pageDto.setTotal(pageInfo.getTotal());

        List<FileDto> fileDtoList = new ArrayList<>();

        for (int i = 0; i < fileList.size(); ++i) {
            File file = fileList.get(i);
            FileDto fileDto = new FileDto();
            BeanUtils.copyProperties(file, fileDto);
            fileDtoList.add(fileDto);
        }
        pageDto.setList(fileDtoList);

    }

    /**
     * 保存，id有值时更新，无值时新增
     */
    public void save(FileDto fileDto) {
        File file = CopyUtil.copy(fileDto, File.class);
        File fileDb = selectByKey(fileDto.getKey());
        if (fileDb == null) {
            this.insert(file);
        } else {
            fileDb.setShardIndex(fileDto.getShardIndex());
            this.update(fileDb);
        }
    }


    private void insert(File file) {
        Date now = new Date();
        file.setCreatedAt(now);
        file.setUpdatedAt(now);
        file.setId(UuidUtil.getShortUuid());
        fileMapper.insert(file);
    }


    private void update(File file) {
        file.setUpdatedAt(new Date());
        fileMapper.updateByPrimaryKey(file);
    }

    public void delete(String id) {
        fileMapper.deleteByPrimaryKey(id);
    }


    public File selectByKey(String key) {
        FileExample example = new FileExample();
        example.createCriteria().andKeyEqualTo(key);
        List<File> fileList = fileMapper.selectByExample(example);
        if (CollectionUtils.isEmpty(fileList)) {
            return null;
        } else {
            return fileList.get(0);
        }
    }
}

```



修改前端 big-file.vue

分片索引

```vue
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
				{{ text }}
			</v-btn>
		</v-col>

		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
		<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];


				// console.log(JSON.stringify(file));
				/*
				  name: "test.mp4"
				  lastModified: 1901173357457
				  lastModifiedDate: Tue May 27 2099 14:49:17 GMT+0800 (中国标准时间) {}
				  webkitRelativePath: ""
				  size: 37415970
				  type: "video/mp4"
				*/
			 
			 // 文件标识
        let key = hex_md5(file);
        let key10 = parseInt(key, 16);
        let key62 = Tool._10to62(key10);
				console.log(key, key10, key62);


				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

				// 文件分片
				let shardSize = 20 * 1024 * 1024; // 20mb为一个分片
				let shardIndex = 1; //分片索引 1标识第一个分片
				let start = (shardIndex-1)* shardSize; // 当前分片起始位置
				let end = Math.min(file.size, start + shardSize); //当前分片结束位置
				let fileShard = file.slice(start, end);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数



				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致
				formData.append('shard', fileShard);
				formData.append('shardIndex', shardIndex);
				formData.append('shardSize', shardSize);
				formData.append('shardTotal', shardTotal);
				formData.append('use', _this.use);
				formData.append('name', file.name);
				formData.append('suffix', suffix);
				formData.append('size', size);
				formData.append('key', key62);

				Loading.show();
				_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', formData).then((response) => {
					Loading.hide();
					let resp = response.data;
					_this.afterUpload(resp);

					// 清空，下次在选择同一个东西时候，也会触发
					$("#" + _this.intputId + "-input").val("");


				})
			},

			selectFile() {
				let _this = this;
				$("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
	input {
		/* 设计透明度 */
		opacity: 0;

	}
</style>

```





# 分片上传功能开发

## 分片数据格式转换，统一系统前后端数据交互传参





fileDto.java



```
package com.lzn.dto;

import java.util.Date;
import com.fasterxml.jackson.annotation.JsonFormat;

public class FileDto {

    /**
     * id
     */
    private String id;

    /**
     * 相对路径
     */
    private String path;

    /**
     * 文件名
     */
    private String name;

    /**
     * 后缀
     */
    private String suffix;

    /**
     * 大小|字节B
     */
    private Integer size;

    /**
     * 用途|枚举[FileUseEnum]：COURSE("C", "讲师"), TEACHER("T", "课程")
     */
    private String use;

    /**
     * 创建时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createdAt;

    /**
     * 修改时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updatedAt;


    private Integer shardIndex;
    private Integer shardSize;
    private Integer shardTotal;
    private String key;

    /**
     * base64
     * @return
     */
    private String shard;

    @Override
    public String toString() {
        return "FileDto{" +
                "id='" + id + '\'' +
                ", path='" + path + '\'' +
                ", name='" + name + '\'' +
                ", suffix='" + suffix + '\'' +
                ", size=" + size +
                ", use='" + use + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                ", shardIndex=" + shardIndex +
                ", shardSize=" + shardSize +
                ", shardTotal=" + shardTotal +
                ", key='" + key + '\'' +
                ", shard='" + shard + '\'' +
                '}';
    }

    public String getShard() {
        return shard;
    }

    public void setShard(String shard) {
        this.shard = shard;
    }

    public Integer getShardIndex() {
        return shardIndex;
    }

    public void setShardIndex(Integer shardIndex) {
        this.shardIndex = shardIndex;
    }

    public Integer getShardSize() {
        return shardSize;
    }

    public void setShardSize(Integer shardSize) {
        this.shardSize = shardSize;
    }

    public Integer getShardTotal() {
        return shardTotal;
    }

    public void setShardTotal(Integer shardTotal) {
        this.shardTotal = shardTotal;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public String getUse() {
        return use;
    }

    public void setUse(String use) {
        this.use = use;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }


}
```





工具类 base64->file

```
package com.lzn.util;

import org.springframework.web.multipart.MultipartFile;
import sun.misc.BASE64Decoder;

import java.io.*;

public class Base64ToMultipartFile implements MultipartFile {

    private final byte[] imgContent;
    private final String header;

    public Base64ToMultipartFile(byte[] imgContent, String header) {
        this.imgContent = imgContent;
        this.header = header.split(";")[0];
    }

    @Override
    public String getName() {
        // TODO - implementation depends on your requirements
        return System.currentTimeMillis() + Math.random() + "." + header.split("/")[1];
    }

    @Override
    public String getOriginalFilename() {
        // TODO - implementation depends on your requirements
        return System.currentTimeMillis() + (int) Math.random() * 10000 + "." + header.split("/")[1];
    }

    @Override
    public String getContentType() {
        // TODO - implementation depends on your requirements
        return header.split(":")[1];
    }

    @Override
    public boolean isEmpty() {
        return imgContent == null || imgContent.length == 0;
    }

    @Override
    public long getSize() {
        return imgContent.length;
    }

    @Override
    public byte[] getBytes() throws IOException {
        return imgContent;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(imgContent);
    }

    @Override
    public void transferTo(File dest) throws IOException, IllegalStateException {
        new FileOutputStream(dest).write(imgContent);
    }

    public static MultipartFile base64ToMultipart(String base64) {
        try {
            String[] baseStrs = base64.split(",");

            BASE64Decoder decoder = new BASE64Decoder();
            byte[] b = new byte[0];
            b = decoder.decodeBuffer(baseStrs[1]);

            for(int i = 0; i < b.length; ++i) {
                if (b[i] < 0) {
                    b[i] += 256;
                }
            }

            return new Base64ToMultipartFile(b, baseStrs[0]);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```





uploadController

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.Base64ToMultipartFile;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(@RequestBody FileDto fileDto) throws IOException {

        LOG.info("上传文件开始");

        String use = fileDto.getUse();
        String key = fileDto.getKey();
        String suffix = fileDto.getSuffix();
        String shardBase64 = fileDto.getShard();
        MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/0mUkwqKQ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/FInyTgeZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}
```



big-file.vue

```vue
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
				{{ text }}
			</v-btn>
		</v-col>

		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
		<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];


				// console.log(JSON.stringify(file));
				/*
				  name: "test.mp4"
				  lastModified: 1901173357457
				  lastModifiedDate: Tue May 27 2099 14:49:17 GMT+0800 (中国标准时间) {}
				  webkitRelativePath: ""
				  size: 37415970
				  type: "video/mp4"
				*/

				// 文件标识
				let key = hex_md5(file);
				let key10 = parseInt(key, 16);
				let key62 = Tool._10to62(key10);
				console.log(key, key10, key62);


				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

				// 文件分片
				let shardSize = 20 * 1024 * 1024; // 20mb为一个分片
				let shardIndex = 1; //分片索引 1标识第一个分片
				let start = (shardIndex - 1) * shardSize; // 当前分片起始位置
				let end = Math.min(file.size, start + shardSize); //当前分片结束位置
				let fileShard = file.slice(start, end);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数



				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致
				formData.append('shard', fileShard);
				formData.append('shardIndex', shardIndex);
				formData.append('shardSize', shardSize);
				formData.append('shardTotal', shardTotal);
				formData.append('use', _this.use);
				formData.append('name', file.name);
				formData.append('suffix', suffix);
				formData.append('size', size);
				formData.append('key', key62);

				// 将图片转为base64进行传输
				let fileReader = new FileReader();
				// event listener
				fileReader.onload = function(e) {
					let base64 = e.target.result;
					// console.log("base64:", base64);

					let param = {
						'shardIndex': shardIndex,
						'shardSize': shardSize,
						'shardTotal': shardTotal,
						'shard': base64,
						'use': _this.use,
						'name': file.name,
						'suffix': suffix,
						'size': file.size,
						'key': key62
					};

					Loading.show();
					_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', param).then((response) => {
						Loading.hide();
						let resp = response.data;
						_this.afterUpload(resp);
						// 清空，下次在选择同一个东西时候，也会触发
						$("#" + _this.intputId + "-input").val("");
					});

				};
				fileReader.readAsDataURL(fileShard);

			},

			selectFile() {
				let _this = this;
				$("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
	input {
		/* 设计透明度 */
		opacity: 0;

	}
</style>

```





## 设置分片文件名

当字符串拼接的个数太多的时候，不要用+ 要用 StringBuilder

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.Base64ToMultipartFile;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(@RequestBody FileDto fileDto) throws IOException {

        LOG.info("上传文件开始");

        String use = fileDto.getUse();
        String key = fileDto.getKey();
        String suffix = fileDto.getSuffix();
        String shardBase64 = fileDto.getShard();
        MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = new StringBuffer(dir)
                .append(File.separator)
                .append(key)
                .append(".")
                .append(suffix)
                .append(".")
                .append(fileDto.getShardIndex())
                .toString();
        String fullPath = FILE_PATH + path;

        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        fileDto.setPath(FILE_DOMAIN + path);
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/0mUkwqKQ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/FInyTgeZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}
```





## 支持连续上传多个分片

在上传结束时，做个判断

shardIndex == shardTotal 就说明全部分片都上传好了

shardIndex < shardTotal说明还有没有上传的分片



big-file.vue

```vue
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
				{{ text }}
			</v-btn>
		</v-col>

		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
		<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];


				// console.log(JSON.stringify(file));
				/*
				  name: "test.mp4"
				  lastModified: 1901173357457
				  lastModifiedDate: Tue May 27 2099 14:49:17 GMT+0800 (中国标准时间) {}
				  webkitRelativePath: ""
				  size: 37415970
				  type: "video/mp4"
				*/

				// 文件标识
				let key = hex_md5(file);
				let key10 = parseInt(key, 16);
				let key62 = Tool._10to62(key10);
				console.log(key, key10, key62);


				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

				// 文件分片
				let shardSize = 20 * 1024 * 1024; // 20mb为一个分片
				let shardIndex = 1; //分片索引 1标识第一个分片
				// let start = (shardIndex - 1) * shardSize; // 当前分片起始位置
				// let end = Math.min(file.size, start + shardSize); //当前分片结束位置
				// let fileShard = file.slice(start, end);
				// let fileShard = _this.getFileShard(shardIndex, shardSize);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数
				let param = {
					'shardIndex': shardIndex,
					'shardSize': shardSize,
					'shardTotal': shardTotal,
					// 'shard': base64,
					'use': _this.use,
					'name': file.name,
					'suffix': suffix,
					'size': file.size,
					'key': key62
				};



				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致

				_this.upload(param);

			},

			upload: function(param) {
				let _this = this;
				let shardIndex = param.shardIndex;
				let shardTotal = param.shardTotal;
				let shardSize = param.shardSize;
				let fileShard = _this.getFileShard(shardIndex, shardSize);
				// 将图片转为base64进行传输
				let fileReader = new FileReader();
				// event listener
				fileReader.onload = function(e) {
					let base64 = e.target.result;
					// console.log("base64:", base64);

					param.shard = base64;

					Loading.show();
					_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', param).then((response) => {
						Loading.hide();
						let resp = response.data;
						if (shardIndex < shardTotal) {
							// 下一个分片
							param.shardIndex = param.shardIndex+1;
							_this.upload(param);
						} else {
							_this.afterUpload(resp);
						}
						// 清空，下次在选择同一个东西时候，也会触发
						$("#" + _this.intputId + "-input").val("");
					});

				};
				fileReader.readAsDataURL(fileShard);
			},
			
			getFileShard(shardIndex, shardSize) {
				let _this = this;
								let file = _this.$refs.file.files[0];
				let start = (shardIndex - 1) * shardSize; // 当前分片起始位置
				let end = Math.min(file.size, start + shardSize); //当前分片结束位置
				
				let fileShard = file.slice(start, end);
				return fileShard;
			},

			selectFile() {
				let _this = this;
				$("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
	input {
		/* 设计透明度 */
		opacity: 0;

	}
</style>

```



# 分片合并功能开发

## 按分片顺序合并成原始文件

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.Base64ToMultipartFile;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(@RequestBody FileDto fileDto) throws Exception {

        LOG.info("上传文件开始");

        String use = fileDto.getUse();
        String key = fileDto.getKey();
        String suffix = fileDto.getSuffix();
        String shardBase64 = fileDto.getShard();
        MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }
        String path = new StringBuffer(dir)
                .append(File.separator)
                .append(key)
                .append(".")
                .append(suffix)
                .toString(); // course\6sfSqfOwzmik4A4icMYuUe.mp4
        String localPath = new StringBuffer(path)
                .append(".")
                .append(fileDto.getShardIndex())
                .toString(); // course\6sfSqfOwzmik4A4icMYuUe.mp4.1
        String fullPath = FILE_PATH + localPath;

        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        fileDto.setPath(FILE_DOMAIN + path);
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        responseDto.setContent(fileDto);

        if(fileDto.getShardTotal() == fileDto.getShardIndex()){
            this.merge(fileDto);
        }

        return responseDto;
    }

    // 合并 分片
//    @GetMapping("/merge")
    public void merge(FileDto fileDto) throws Exception {
        String path = fileDto.getPath(); //http://127.0.0.1:9000/file/f/course\6sfSqfOwzmik4A4icMYuUe.mp4
        path = path.replace(FILE_DOMAIN, ""); //course\6sfSqfOwzmik4A4icMYuUe.mp4
        Integer shardTotal = fileDto.getShardTotal();
        File newFile = new File(FILE_PATH + path);
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            for (int i = 0; i < shardTotal; i++) {
                // 读取第i个分片
                fileInputStream = new FileInputStream(new File(FILE_PATH + path + "." + (i + 1))); //  course\6sfSqfOwzmik4A4icMYuUe.mp4.1
                while ((len = fileInputStream.read(byt)) != -1) {
                    outputStream.write(byt, 0, len);
                }
            }
        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }
    }
}
```