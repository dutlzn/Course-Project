---

---

#  大文件断点续传与极速秒传

# 分片传输的试探

文件越大，上传失败率越大

当文件上传到一般，网络断了，下次再上传，只上传剩下的一般，这就是

断点续传



极速秒传，开始上传之前，先检查一下文件有没有上传过，

如果已经上传过了，直接弹出提示，极速秒传成功



一个文件有10m，每个分片定义为1m， 那这个文件就会被分为10片



前端，拷贝file.vue 组件， 定义为big-file.vue



big-file.vue 

```vue
		if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}

// 文件分片
				let shardSize = 20*1024*1024;// 20mb为一个分片
				let shardIndex = 1;//分片索引
				let start = shardIndex * shardSize;// 当前分片起始位置
				let end = Math.min(file.size, start + shardSize);//当前分片结束位置
				let fileShard = file.slice(start, end);
				
				console.log(fileShard);
				
				formData.append('file', fileShard);
				formData.append('use', _this.use);
				
```



## 分片的合并

后端

```java
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(
            @RequestParam MultipartFile file,
            String use
            ) throws IOException {

        LOG.info(file.getOriginalFilename());
        LOG.info(String.valueOf(file.getSize()));

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        String fileName=  file.getOriginalFilename();
        String suffix = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
        String key = UuidUtil.getShortUuid();

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        file.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        FileDto fileDto = new FileDto();
        fileDto.setPath(path);
        fileDto.setName(fileName);
        fileDto.setSize(Math.toIntExact(file.getSize()));
        fileDto.setSuffix(suffix);
        fileDto.setUse(use);


        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test1234.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/RGg2NUt6.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/WWn2wJyZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}

```

先测试一下

http://localhost:9000/file/admin/merge

这里要注意一个东西就是一个文件需要完整分割成几份，合并起来才可以播放





# 分片上传功能开发

## 数据库

```sql
alter table `file` add column (`shard_index` int comment '已上传分片');
alter table `file` add column (`shard_size` int comment '分片大小|B');
alter table `file` add column (`shard_total` int comment '分片总数');
alter table `file` add column (`key` varchar(32) comment '文件标识');
alter table `file` add unique key key_unique (`key`);

```

不管传过来第几个分片，key是一样的



mybatis file 生成持久层代码





## 分片数据传输

经验： 对于一些不涉及安全性的数据，可以交由前端来计算，这样可以减轻服务端的压力



fileDto

```
package com.lzn.dto;

import java.util.Date;
import com.fasterxml.jackson.annotation.JsonFormat;

public class FileDto {

    /**
     * id
     */
    private String id;

    /**
     * 相对路径
     */
    private String path;

    /**
     * 文件名
     */
    private String name;

    /**
     * 后缀
     */
    private String suffix;

    /**
     * 大小|字节B
     */
    private Integer size;

    /**
     * 用途|枚举[FileUseEnum]：COURSE("C", "讲师"), TEACHER("T", "课程")
     */
    private String use;

    /**
     * 创建时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createdAt;

    /**
     * 修改时间
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updatedAt;


    private Integer shardIndex;
    private Integer shardSize;
    private Integer shardTotal;
    private String key;

    @Override
    public String toString() {
        return "FileDto{" +
                "id='" + id + '\'' +
                ", path='" + path + '\'' +
                ", name='" + name + '\'' +
                ", suffix='" + suffix + '\'' +
                ", size=" + size +
                ", use='" + use + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                ", shardIndex=" + shardIndex +
                ", shardSize=" + shardSize +
                ", shardTotal=" + shardTotal +
                ", key='" + key + '\'' +
                '}';
    }

    public Integer getShardIndex() {
        return shardIndex;
    }

    public void setShardIndex(Integer shardIndex) {
        this.shardIndex = shardIndex;
    }

    public Integer getShardSize() {
        return shardSize;
    }

    public void setShardSize(Integer shardSize) {
        this.shardSize = shardSize;
    }

    public Integer getShardTotal() {
        return shardTotal;
    }

    public void setShardTotal(Integer shardTotal) {
        this.shardTotal = shardTotal;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public String getUse() {
        return use;
    }

    public void setUse(String use) {
        this.use = use;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }


}
```



big-file.vue

```
<template>
	<div>

		<v-col cols="3">
			<v-btn v-on:click="selectFile()" class="warning">
				<!-- <v-icon>upload</v-icon> -->
					{{ text }}
			</v-btn>
		</v-col>
		
		<input ref="file" v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()">
	<!-- 	 <v-file-input

				ref="file"
			  v-bind:id="inputId+'-input'" type="file" v-on:change="uploadFile()"
		  ></v-file-input> -->
	</div>
</template>

<script>
	export default {
		name: 'file',
		props: {
			text: {
				default: "上传文件"
			},
			inputId: {
				default: "file-upload"
			},
			suffixs: {
				default: []
			},
			use: {
				default: ""
			},
			afterUpload: {
				type: Function,
				default: null
			}
		},
		data: function() {
			return {

			};
		},
		methods: {

			uploadFile() {
				let _this = this;
				let formData = new window.FormData();
				// key: "file"必须和后端controller参数名一样
				let file = _this.$refs.file.files[0];
				// 判断文件格式
				let suffixs = _this.suffixs;
				let fileName = file.name;
				let suffix = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();

				let validateSuffix = false;
				for (let i = 0; i < suffixs.length; ++i) {
					if (suffixs[i].toLowerCase() === suffix) {
						validateSuffix = true;
						break;
					}
				}

				if (!validateSuffix) {
					Toast.warning("文件格式不正确,只支持上传:" + suffixs.join(","));
					$("#" + _this.inputId + "-input").val("");
					return;
				}
				
				// 文件分片
				let shardSize = 20*1024*1024;// 20mb为一个分片
				let shardIndex = 1;//分片索引
				let start = shardIndex * shardSize;// 当前分片起始位置
				let end = Math.min(file.size, start + shardSize);//当前分片结束位置
				let fileShard = file.slice(start, end);
				let size = file.size;
				let shardTotal = Math.ceil(size / shardSize); // 总片数
				
				
				
				// console.log(fileShard);
				// key: "shard" 必须和后端controller参数名一致
				formData.append('shard', fileShard);
				formData.append('shardIndex', shardIndex);
				formData.append('shardSize', shardSize);
			  formData.append('shardTotal', shardTotal);
				formData.append('use', _this.use);
				formData.append('name', file.name);
				formData.append('suffix', suffix);
				formData.append('size', size);
				
				Loading.show();
				_this.$ajax.post(process.env.VUE_APP_SERVER + '/file/admin/upload', formData).then((response) => {
					Loading.hide();
					let resp = response.data;
					_this.afterUpload(resp);
					
					// 清空，下次在选择同一个东西时候，也会触发
					$("#" + _this.intputId + "-input").val("");
					

				})
			},

			selectFile() {
				let _this = this;
        $("#" + _this.inputId + "-input").trigger("click");
			}
		}
	}
</script>

<style scoped>
   input {
		 /* 设计透明度 */
     opacity: 0;

    }
</style>

```



key是唯一建，不能为空，所以先存短uuid，让程序走通

```
package com.lzn.file.controller.admin;


import com.lzn.dto.FileDto;
import com.lzn.dto.ResponseDto;
import com.lzn.enums.FileUseEnum;
import com.lzn.service.FileService;
import com.lzn.util.UuidUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


@RequestMapping("/admin")
@RestController
public class UploadController {

    @Value("${file.path}")
    private String FILE_PATH;
    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Autowired
    private FileService fileService;

    private static final Logger LOG = LoggerFactory.getLogger(
            UploadController.class
    );


    public static final String BUSINESS_NAME = "文件上传";


    @RequestMapping("/upload")
    public ResponseDto upload(
            @RequestParam MultipartFile shard,
            String use,
            String name,
            String suffix,
            Integer size,
            Integer shardIndex,
            Integer shardSize,
            Integer shardTotal
            ) throws IOException {

        LOG.info("上传文件开始");

        // 保存文件到本地
        FileUseEnum useEnum = FileUseEnum.getByCode(use);

        String key = UuidUtil.getShortUuid();

        // 如果文件夹不存在则创建
        String dir = useEnum.name().toLowerCase();
        File fullDir = new File(FILE_PATH + dir);
        if( !fullDir.exists()){
            fullDir.mkdir();
        }

        String path  = dir +  File.separator + key + "." + suffix;

        String fullPath =FILE_PATH  + path;
        // 文件的路径应该是自动生成的
        File dest = new File(fullPath);// 生成目标位置
        shard.transferTo(dest);// 写道目标位置
        LOG.info(dest.getAbsolutePath());

        LOG.info("保存文件记录开始");
        FileDto fileDto = new FileDto();
        fileDto.setPath(path);
        fileDto.setName(name);
        fileDto.setSize(size);
        fileDto.setSuffix(suffix);
        fileDto.setUse(use);
        fileDto.setShardIndex(shardIndex);
        fileDto.setShardSize(shardSize);
        fileDto.setShardTotal(shardTotal);
        fileDto.setKey(key);
        fileService.save(fileDto);

        ResponseDto responseDto = new ResponseDto();
        fileDto.setPath(FILE_DOMAIN + path);
        responseDto.setContent(fileDto);
        return responseDto;
    }

    // 合并 分片
    @GetMapping("/merge")
    public ResponseDto merge() throws Exception {
        File newFile = new File(FILE_PATH + "/course/test.mp4");
        FileOutputStream outputStream = new FileOutputStream(newFile, true);// 文件追加写入
        FileInputStream fileInputStream = null; // 分片文件
        byte[] byt = new byte[1024*1024*10];
        int len;

        try {
            // 读取第一个分片
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/0mUkwqKQ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }
            fileInputStream = new FileInputStream(new File(FILE_PATH + "/course/FInyTgeZ.blob"));
            while( (len = fileInputStream.read(byt)) != -1) {
                outputStream.write(byt, 0, len);
            }

        } catch(IOException e){
            LOG.error("分片合并异常", e);
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                outputStream.close();
                LOG.info("IO流关闭");
            } catch (Exception e) {
                LOG.error("IO流关闭", e);
            }
        }

        ResponseDto responseDto = new ResponseDto();
        return responseDto;
    }
}
```